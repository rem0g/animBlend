<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Babylon.js GLB Viewer</title>
    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }
        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        /* Add slider control styles */
        .control-panel {
            position: absolute;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            border-radius: 5px;
            z-index: 100;
        }
        .rotation-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 10px;
        }
        .rotation-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .rotation-control label {
            width: 20px;
            text-align: right;
        }
        .rotation-control input[type="range"] {
            flex: 1;
        }
        .rotation-control span {
            width: 40px;
            text-align: right;
        }
        
        /* Timeline editor styles */
        .timeline-editor {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            background-color: rgba(32, 32, 32, 0.8);
            border-radius: 8px;
            color: white;
            padding: 15px;
            font-family: Arial, sans-serif;
            z-index: 100;
        }
        .timeline-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .timeline-track {
            position: relative;
            height: 40px;
            background-color: #363636;
            border-radius: 4px;
            cursor: pointer;
        }
        .timeline-track-label {
            position: absolute;
            left: -70px;
            top: 50%;
            transform: translateY(-50%);
            width: 65px;
            text-align: right;
            font-size: 12px;
            color: #ddd;
            opacity: 0.9;
        }
        .timeline-playhead {
            position: absolute;
            width: 2px;
            height: 100%;
            background-color: #ff5555;
            top: 0;
            left: 0;
            pointer-events: none;
        }
        .timeline-segment {
            position: absolute;
            height: 100%;
            background-color: #4d9cdb;
            opacity: 0.8;
            top: 0;
            border-radius: 2px;
        }
        .timeline-insertion-marker {
            position: absolute;
            width: 2px;
            height: 100%;
            background-color: #ffcc00;
            top: 0;
            pointer-events: none;
        }
        .timeline-time-markers {
            position: relative;
            height: 15px;
            margin-top: 2px;
        }
        .timeline-time-marker {
            position: absolute;
            width: 1px;
            height: 5px;
            background-color: #888;
            top: 0;
        }
        .timeline-time-label {
            position: absolute;
            top: 6px;
            transform: translateX(-50%);
            font-size: 10px;
            color: #888;
        }
        .timeline-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .timeline-button {
            background-color: #444;
            border: none;
            color: white;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            transition: background-color 0.2s;
        }
        .timeline-button:hover {
            background-color: #555;
        }
        .timeline-time-display {
            font-family: monospace;
            font-size: 14px;
            background-color: #222;
            padding: 5px 10px;
            border-radius: 3px;
            min-width: 120px;
            text-align: center;
        }
        .timeline-zoom-controls {
            display: flex;
            gap: 8px;
        }
        /* Timeline Editor styles */
        #timelineEditor {
            position: relative;
            width: 100%;
            background-color: #2a2a2a;
            border-top: 1px solid #444;
            height: 160px;
            display: flex;
            flex-direction: column;
            user-select: none;
        }
        
        .timeline-controls {
            height: 30px;
            background-color: #333;
            display: flex;
            align-items: center;
            padding: 0 10px;
        }
        
        .timeline-controls button {
            background-color: #444;
            border: none;
            color: white;
            padding: 5px 10px;
            border-radius: 3px;
            margin-right: 10px;
            cursor: pointer;
        }
        
        .timeline-controls button:hover {
            background-color: #555;
        }
        
        #timelineTimeDisplay {
            color: white;
            font-family: monospace;
            background-color: #222;
            padding: 3px 8px;
            border-radius: 3px;
            margin: 0 15px;
        }
        
        .timeline-container {
            flex-grow: 1;
            display: flex;
            position: relative;
        }
        
        .timeline-labels {
            width: 60px;
            background-color: #222;
            display: flex;
            flex-direction: column;
        }
        
        .timeline-track-label {
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #ddd;
            border-bottom: 1px solid #444;
            font-size: 12px;
        }
        
        .timeline-tracks {
            flex-grow: 1;
            position: relative;
            overflow-x: auto;
            background-color: #1a1a1a;
        }
        
        .timeline-track {
            height: 50px;
            position: relative;
            border-bottom: 1px solid #333;
        }
        
        .timeline-clip {
            position: absolute;
            height: 70%;
            top: 15%;
            border-radius: 3px;
            cursor: move;
            opacity: 0.8;
            min-width: 4px; /* Ensure clips are always visible */
            z-index: 5;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        
        /* Add resize handles to timeline clips */
        .timeline-clip::before,
        .timeline-clip::after {
            content: "";
            position: absolute;
            width: 8px;
            height: 100%;
            top: 0;
            background-color: rgba(255, 255, 255, 0.2);
            cursor: ew-resize;
        }
        
        .timeline-clip::before {
            left: 0;
        }
        
        .timeline-clip::after {
            right: 0;
        }
        
        .base-clip {
            background-color: #4a6fa8;
            border: 1px solid #5d84c0;
        }
        
        .gloss-clip {
            background-color: #8c6d3f;
            border: 1px solid #ad8a53;
        }
        
        .timeline-playhead {
            position: absolute;
            width: 2px;
            height: 100%;
            background-color: red;
            top: 0;
            pointer-events: none;
        }
        
        .timeline-marker {
            position: absolute;
            width: 3px;
            height: 130px;
            background-color: #3fca7d;
            top: 0;
            cursor: ew-resize;
            z-index: 10;
        }
        
        .timeline-marker::after {
            content: "";
            position: absolute;
            top: -6px;
            left: -4px;
            width: 10px;
            height: 10px;
            background-color: #3fca7d;
            transform: rotate(45deg);
        }
        
        .timeline-markers {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 100%;
            pointer-events: none;
        }
        
        .timeline-time-marker {
            position: absolute;
            width: 1px;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.15);
            pointer-events: none;
        }
        
        .timeline-time-marker::after {
            content: attr(data-time);
            position: absolute;
            top: 0;
            left: 2px;
            font-size: 10px;
            color: #999;
        }
        body { margin: 0; overflow: hidden; }
        canvas { width: 100%; height: 100%; display: block; }
        #buttonContainer { 
            position: fixed; 
            top: 10px; 
            right: 10px; 
            display: flex; 
            flex-direction: column;
        }
        #loadAnimationBtn, #stopBtn, #connectAnimBtn, #addAnimationButton {
            margin: 5px;
            padding: 10px;
            cursor: pointer;
        }
        #progressBarContainer {
            width: 90%;
            background-color: #f1f1f1;
            margin: 0 auto;
        }
        #progressBar {
            width: 0%;
            height: 30px;
            background-color: #4CAF50;
            text-align: center;
            line-height: 30px;
            color: white;
        }
        
        /* Timeline Editor Styles */
        #timelineEditor {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: #2a2a2a;
            color: #fff;
            padding: 10px;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.3);
            z-index: 100;
        }
        
        .timeline-controls {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .timeline-controls button {
            background: #444;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 5px 10px;
            margin-right: 10px;
            cursor: pointer;
        }
        
        .timeline-controls button:hover {
            background: #555;
        }
        
        #timelineTimeDisplay {
            margin-left: auto;
            font-family: monospace;
            font-size: 14px;
        }
        
        .timeline-container {
            display: flex;
            height: 100px;
        }
        
        .timeline-labels {
            width: 60px;
            padding-right: 10px;
            display: flex;
            flex-direction: column;
            justify-content: space-around;
        }
        
        .timeline-track-label {
            height: 30px;
            display: flex;
            align-items: center;
            font-size: 12px;
        }
        
        .timeline-tracks {
            flex-grow: 1;
            position: relative;
            border: 1px solid #555;
            background: #333;
            overflow-x: auto;
        }
        
        .timeline-track {
            height: 30px;
            margin: 5px 0;
            background: #444;
            position: relative;
        }
        
        .animation-clip {
            position: absolute;
            height: 100%;
            background: linear-gradient(to bottom, #4CAF50 0%, #2d7d32 100%);
            border-radius: 3px;
            cursor: move;
            color: white;
            font-size: 11px;
            display: flex;
            align-items: center;
            padding: 0 5px;
            overflow: hidden;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        
        .timeline-playhead {
            position: absolute;
            top: 0;
            width: 2px;
            height: 100%;
            background-color: red;
            z-index: 10;
            pointer-events: none;
        }
        
        .timeline-marker {
            position: absolute;
            top: 0;
            width: 2px;
            height: 100%;
            background-color: #ffcc00;
            z-index: 5;
            cursor: col-resize;
        }
        
        .timeline-markers {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 15px;
            display: flex;
            z-index: 1;
            pointer-events: none;
        }
        
        .time-marker {
            position: absolute;
            width: 1px;
            height: 5px;
            background-color: #888;
            bottom: 0;
        }
        
        .time-marker-label {
            position: absolute;
            bottom: 5px;
            transform: translateX(-50%);
            font-size: 9px;
            color: #aaa;
        }
        
        .time-marker.major {
            height: 10px;
            background-color: #aaa;
        }
    </style>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <!-- Include Earcut library (dependency for MeshWriter) -->
    <script src="https://unpkg.com/earcut@2.2.4/dist/earcut.min.js"></script>
    <!-- Include MeshWriter library -->
    <script src="https://cdn.jsdelivr.net/npm/meshwriter@1.0.1/dist/meshwriter.min.js"></script>
    <!-- Include our custom JS files -->
    <script src="SceneAndMeshLoader.js"></script>
    <script src="retargetAnims.js"></script>
    <script src="animFetchAndDestroy.js"></script>
    <script src="initialize.js"></script>
    <!-- Include our new modular JavaScript files -->
    <script src="js/AnimationUtils.js"></script>
    <script src="js/TimelineController.js"></script>
    <script src="js/AnimationController.js"></script>
    <script src="js/UIController.js"></script>
    <script src="js/app.js"></script>
</head>
<body>
    <div id="applicationContainer">
       

        <div id="mainPanel">
            <canvas id="renderCanvas"></canvas>
            
            <!-- Timeline Editor -->
            <div id="timelineEditor">
                <div class="timeline-controls">
                    <button id="timelinePlayPauseBtn">Play</button>
                    <button id="timelineResetBtn">Reset</button>
                    <div class="timeline-zoom-controls">
                        <button id="timelineZoomInBtn">+</button>
                        <button id="timelineZoomOutBtn">-</button>
                    </div>
                    <span id="timelineTimeDisplay">00:00.000</span>
                </div>
                <div class="timeline-container">
                    <div class="timeline-labels">
                        <div class="timeline-track-label">Base</div>
                        <div class="timeline-track-label">Gloss</div>
                    </div>
                    <div class="timeline-tracks">
                        <div class="timeline-track">
                            <div id="baseAnimTrack" class="timeline-clip base-clip"></div>
                            <div id="basePlayhead" class="timeline-playhead"></div>
                        </div>
                        <div class="timeline-track">
                            <div id="glossAnimTrack" class="timeline-clip gloss-clip"></div>
                            <div id="glossPlayhead" class="timeline-playhead"></div>
                        </div>
                        <div id="glossInsertionMarker" class="timeline-marker"></div>
                        <div id="timelineMarkers" class="timeline-markers"></div>
                    </div>
                </div>
            </div>
        </div>

        <div id="rightPanel">
    <!-- <canvas id="renderCanvas"></canvas> --> <!-- Ensure this remains commented out or removed -->

    <div id="animationBlendingControls" style="position: absolute; top: 150px; left: 10px; background-color: rgba(0,0,0,0.7); color: white; padding: 15px; border-radius: 8px; z-index: 100; font-family: Arial, sans-serif; font-size: 14px; width: 320px;">
        <h4 style="margin-top: 0; margin-bottom: 10px; border-bottom: 1px solid #555; padding-bottom: 5px;">Animation Blending & Splicing</h4>

        <div style="margin-bottom: 10px;">
            <label for="sentenceAnimation" style="display: block; margin-bottom: 3px;">Base Sentence (from zin_glb/):</label>
            <select id="sentenceAnimation" style="width: 100%; padding: 5px; display: block !important; visibility: visible !important;"></select>
        </div>

        <div style="border: 1px solid #777; padding: 10px; margin-bottom: 10px; border-radius: 4px;">
            <h5 style="margin-top:0; margin-bottom: 8px;">Base Animation Segment:</h5>
            <div style="margin-bottom: 10px;">
                <label for="baseCutStartTime" style="display: block; margin-bottom: 3px;">1. Gloss Insertion Time (in Base Anim) (s):</label>
                <input type="number" id="baseCutStartTime" value="1" step="0.1" style="width: 95%; padding: 5px;">
            </div>
            <!-- REMOVED Base Resume Time input -->
        </div>

        <div style="margin-bottom: 10px;">
            <label for="insertGlossAnimation" style="display: block; margin-bottom: 3px;">2. Gloss to Insert (from glos_glb/):</label>
            <select id="insertGlossAnimation" style="width: 100%; padding: 5px; display: block !important; visibility: visible !important;"></select>
        </div>

        <div style="border: 1px solid #777; padding: 10px; margin-bottom: 10px; border-radius: 4px;">
            <h5 style="margin-top:0; margin-bottom: 8px;">Gloss Animation Segment:</h5>
            <div style="margin-bottom: 10px;">
                <label for="glossPlayStartTime" style="display: block; margin-bottom: 3px;">Play Gloss From (seconds):</label>
                <input type="number" id="glossPlayStartTime" value="0" step="0.1" style="width: 95%; padding: 5px;">
            </div>
            <div style="margin-bottom: 10px;">
                <label for="glossPlayEndTime" style="display: block; margin-bottom: 3px;">Play Gloss To (seconds, 0 for full):</label>
                <input type="number" id="glossPlayEndTime" value="0" step="0.1" style="width: 95%; padding: 5px;">
            </div>
        </div>

        <div style="margin-bottom: 15px;">
            <label for="blendDuration" style="display: block; margin-bottom: 3px;">Gloss Blend Duration (s) (e.g., 0.1 - 0.5):</label>
            <input type="number" id="blendDuration" value="0.1" step="0.01" style="width: 95%; padding: 5px;">
        </div>
        
        <div style="margin-bottom: 15px;">
            <label for="blendBalance" style="display: block; margin-bottom: 3px;">Blend Balance (0-1, 0.5 is equal):</label>
            <div style="display: flex; align-items: center;">
                <span style="flex: 0 0 40px; text-align: left;">Base</span>
                <input type="range" id="blendBalance" min="0" max="1" step="0.1" value="0.5" style="flex: 1; margin: 0 10px;">
                <span style="flex: 0 0 40px; text-align: right;">Gloss</span>
            </div>
            <input type="number" id="blendBalanceValue" value="0.5" step="0.1" min="0" max="1" style="width: 60px; padding: 5px; margin-top: 5px;">
        </div>
        
        <button id="applyBlendButton" style="padding: 8px 12px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; width: 100%; margin-bottom: 5px;">Apply and Play Spliced Animation</button>
        <button id="playOriginalSentenceButton" style="padding: 8px 12px; background-color: #008CBA; color: white; border: none; border-radius: 4px; cursor: pointer; width: 100%;">Play Selected Sentence</button>
    </div>

    <!-- Only keep one timeline editor UI -->
    <!-- <div id="timelineEditor">
        <div class="timeline-controls">
            <button id="playPauseBtn">Play</button>
            <button id="zoomInBtn">Zoom In</button>
            <button id="zoomOutBtn">Zoom Out</button>
            <span id="timelineTimeDisplay">00:00.000</span>
        </div>
        <div class="timeline-container">
            <div class="timeline-labels">
                <div class="timeline-track-label">Base</div>
                <div class="timeline-track-label">Gloss</div>
            </div>
            <div class="timeline-tracks" id="timelineTracks">
                <div class="timeline-track" id="baseTrack"></div>
                <div class="timeline-track" id="glossTrack"></div>
                <div class="timeline-markers" id="timelineMarkers">
                </div>
                <div class="timeline-playhead" id="timelinePlayhead"></div>
                <div class="timeline-marker" id="glossMarker" title="Gloss insertion point"></div>
            </div>
        </div>
    </div> -->

    <script>
        const canvas = document.getElementById("renderCanvas");
        
        // Create engine with proper error handling and fallback options
        let engine;
        try {
            // Try creating engine with explicit WebGL version options
            const options = {
                antialias: true,
                preserveDrawingBuffer: true,
                stencil: true,
                premultipliedAlpha: false,
                useWebGL2IfAvailable: false // Force WebGL 1 to avoid the getContextAttributes issue
            };
            
            // Create canvas context manually first to ensure it works
            const context = canvas.getContext("webgl", options) || canvas.getContext("experimental-webgl", options);
            
            if (!context) {
                throw new Error("WebGL context could not be created");
            }
            
            // Create engine with the existing context
            engine = new BABYLON.Engine(canvas, true, options);
            console.log("WebGL 1 engine created successfully");
        } catch (e) {
            console.error("Failed to initialize Babylon.js engine:", e);
            alert("Your browser may not support WebGL. Please try using an updated browser that supports WebGL.");
        }

        const setupScene = async function () {
            if (!engine) {
                console.error("Cannot setup scene: Engine initialization failed");
                return;
            }
            
            // Create scene using our utility function from SceneAndMeshLoader.js
            // Pass the existing engine to createScene to avoid creating a duplicate WebGL context
            const [scene, _] = await createScene(canvas, engine);
            window.scene = scene; // Make scene globally accessible
            
            // Set scene background to white
            scene.clearColor = new BABYLON.Color3(1, 1, 1); // White background
            
            // Add a camera with improved settings for close-up viewing
            const camera = new BABYLON.ArcRotateCamera("camera", Math.PI / 2, Math.PI / 2.5, 3, new BABYLON.Vector3(0, 1, 0), scene);
            
            // FIX FOR CLIPPING: Set extremely small near clip plane to prevent disappearing when close
            camera.minZ = 0.01; // Default is 0.1 or 1.0, this allows much closer viewing
            
            camera.attachControl(canvas, true);
            camera.wheelDeltaPercentage = 0.015;
            camera.panningSensibility = 0; // Setting to 0 disables panning

            // Add a light
            const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
            light.intensity = 0.7;

            // Store baseMeshAsset globally for access by animation loading functions
            window.globalBaseMeshAsset = null;
            window.allRetargetedAnimations = { zin: {}, glos: {} };
            // window.currentActiveAnimationGroupInSequence = null; // Will be replaced by currentBaseAnim and currentGlossAnim
            // window.animationSequencePlayer = { ... }; // REMOVE OLD PLAYER

            // NEW: Global variables for the new blending approach
            // These are moved to the new script block
            // window.currentBaseAnim = null;
            // window.currentGlossAnim = null;
            // window.glossInsertionTimer = null;
            // window.glossStopTimer = null;
            window.activeAnimForGlobalPlayPause = null; // To simplify global play/pause

            // --- Animation Sequence Player (OLD - to be removed or refactored) ---
            /*
            let animationSequencePlayer = {
                // ... (entire object definition to be removed)
            };
            */

            /*
            function playPart1() {
                // ... (entire function definition to be removed)
            }
            */

            /*
            function playPart2() {
                // ... (entire function definition to be removed)
            }
            */

            /*
            function playPart3() {
                // ... (entire function definition to be removed)
            }
            */

            // --- NEW Animation Blending Logic ---
            // MOVED TO NEW SCRIPT BLOCK AT THE END OF BODY

            // Load the base model with meshes and textures
            const baseModelUrl = "https://signcollect.nl/jari/BabylonSignLab/LoadingAnimation/MeshesAndAnims/glassesGuyNew.glb";
            
            // Parse URL parameters to get glossId - This might be used for an initial animation or removed
            const urlParams = new URLSearchParams(window.location.search);
            const glossId = urlParams.get('glossId');
            
            // Default animation URL - This will be largely superseded by the new UI
            let animModelUrl = "https://signcollect.nl/gebarenoverleg_media/slat2025/glos_glb/1_250507_12.glb";
            
            // --- NEW Animation Loading and Management ---
            window.loadAnimationByName = async function(filename, type, scene, baseMeshAsset) {
                if (!filename) {
                    console.warn("[loadAnimationByName] No filename provided for type:", type);
                    return null;
                }
                const subfolder = type === 'zin' ? 'zin_glb' : 'glos_glb';

                // Use window.allRetargetedAnimations as the primary cache for AnimationGroups
                if (window.allRetargetedAnimations[type] && window.allRetargetedAnimations[type][filename]) {
                    const cachedAnim = window.allRetargetedAnimations[type][filename];
                    // Integrity check for the cached animation group
                    if (cachedAnim && cachedAnim instanceof BABYLON.AnimationGroup && 
                        typeof cachedAnim.start === 'function' && 
                        typeof cachedAnim.enableBlending === 'function') { // Key check for blending
                        console.log(`[loadAnimationByName] Returning VALID cached animation ${filename} from window.allRetargetedAnimations.`);
                        return cachedAnim;
                    } else {
                        console.warn(`[loadAnimationByName] Cached animation ${filename} in window.allRetargetedAnimations seems corrupted or invalid (is AG: ${cachedAnim instanceof BABYLON.AnimationGroup}, has start: ${typeof cachedAnim.start}, has enableBlending: ${typeof cachedAnim.enableBlending}). Will reload.`);
                    }
                }

                const animFileUrl = `https://signcollect.nl/gebarenoverleg_media/slat2025/${subfolder}/${filename}`;
                console.log(`[loadAnimationByName] Loading animation: ${animFileUrl}`);

                try {
                    const animUrlParts = animFileUrl.split('/');
                    const animFileName = animUrlParts.pop();
                    const animPath = animUrlParts.join('/') + '/';

                    const loadedAsset = await BABYLON.SceneLoader.ImportMeshAsync("", animPath, animFileName, scene);

                    loadedAsset.meshes.forEach(mesh => {
                        if (mesh.id !== "__root__" && baseMeshAsset.fetched.meshes.indexOf(mesh) === -1) {
                            mesh.isVisible = false;
                        }
                    });

                    if (loadedAsset.animationGroups && loadedAsset.animationGroups.length > 0) {
                        const animGroup = loadedAsset.animationGroups[0];
                        animGroup.stop();
                        console.log(`[loadAnimationByName] Original AnimationGroup from ${filename}:`, animGroup);

                        const retargetedAnim = retargetAnimWithBlendshapes(
                            baseMeshAsset,
                            animGroup,
                            `Retargeted_${type}_${filename.replace(/[^a-zA-Z0-9_]/g, '_')}`
                        );

                        if (retargetedAnim) {
                            console.log(`[loadAnimationByName] Received retargetedAnim for ${filename}.`);
                            console.log(`  Type: ${typeof retargetedAnim}`);
                            console.log(`  Constructor: ${retargetedAnim.constructor ? retargetedAnim.constructor.name : 'N/A'}`);
                            console.log(`  Is BABYLON.AnimationGroup instance: ${retargetedAnim instanceof BABYLON.AnimationGroup}`);
                            console.log(`  typeof .start: ${typeof retargetedAnim.start}`);
                            console.log(`  typeof .stop: ${typeof retargetedAnim.stop}`);
                            console.log(`  typeof .play: ${typeof retargetedAnim.play}`);
                            console.log(`  typeof .pause: ${typeof retargetedAnim.pause}`);
                            console.log(`  typeof .reset: ${typeof retargetedAnim.reset}`);
                            console.log(`  typeof .dispose: ${typeof retargetedAnim.dispose}`);
                            console.log(`  typeof .enableBlending: ${typeof retargetedAnim.enableBlending}`); // Log this specifically
                            
                            // CRITICAL CHECK for enableBlending
                            if (typeof retargetedAnim.enableBlending !== 'function') {
                                console.error(`[loadAnimationByName] CRITICAL ISSUE DETECTED for ${filename}: retargetedAnim.enableBlending is of type '${typeof retargetedAnim.enableBlending}', but it MUST be a function. This indicates a problem within retargetAnimWithBlendshapes or how AnimationGroups are handled post-retargeting. Playback will likely fail for this animation.`);
                            }

                            if (!(retargetedAnim instanceof BABYLON.AnimationGroup) || typeof retargetedAnim.start !== 'function') {
                                console.error(`[loadAnimationByName] CRITICAL FAILURE: The object returned by retargetAnimWithBlendshapes for ${filename} is NOT a valid BABYLON.AnimationGroup instance with required methods (e.g., start is missing or not a function). Playback will fail. This likely indicates an issue within retargetAnimWithBlendshapes.`);
                            }

                            try {
                                retargetedAnim.name = filename; // Set name for easier identification
                            } catch (e) {
                                console.warn(`[loadAnimationByName] Could not set name on retargetedAnim for ${filename}: ${e.message}`);
                            }
                            // Ensure the type sub-object exists (it should from global initialization, but good practice)
                            if (!window.allRetargetedAnimations[type]) {
                                window.allRetargetedAnimations[type] = {};
                            }
                            window.allRetargetedAnimations[type][filename] = retargetedAnim;
                            console.log(`[loadAnimationByName] Stored retargeted animation in cache: ${filename}`);
                            animGroup.dispose(); // Dispose the original animation group from the loaded asset
                            return retargetedAnim;
                        } else {
                            console.error(`[loadAnimationByName] retargetAnimWithBlendshapes returned null or undefined for ${filename}`);
                            animGroup.dispose(); // Still dispose the original
                        }
                    } else {
                        console.warn(`[loadAnimationByName] No animation groups found in ${filename}`);
                    }
                } catch (error) {
                    console.error(`[loadAnimationByName] Error loading or processing animation ${filename}:`, error);
                }
                return null;
            };

            async function fetchAnimationFilesAndPopulateDropdowns() {
                try {
                    console.log("Attempting to fetch animation files list...");
                    // IMPORTANT: Replace with the correct path to your listAnimationFiles.php
                    const response = await fetch('listAnimationFiles.php');
                    console.log("Response status:", response.status, response.statusText);
                    
                    if (!response.ok) {
                        throw new Error(`Server responded with status: ${response.status}`);
                    }
                    
                    // Debug: Log raw response text first
                    const responseText = await response.text();
                    console.log("Raw response:", responseText);
                    
                    // Parse as JSON after logging the raw text
                    let data;
                    try {
                        data = JSON.parse(responseText);
                    } catch (parseError) {
                        console.error("Failed to parse JSON response:", parseError);
                        throw new Error("Invalid JSON response from server");
                    }

                    console.log("Parsed data:", data);

                    if (data.success) {
                        const sentenceSelect = document.getElementById('sentenceAnimation');
                        const glossSelect = document.getElementById('insertGlossAnimation');
                        
                        console.log(`Found ${data.zin?.length || 0} sentence animations and ${data.glos?.length || 0} gloss animations`);
                        
                        sentenceSelect.innerHTML = '<option value="">Select Sentence...</option>'; // Placeholder
                        if (data.zin && Array.isArray(data.zin)) {
                            data.zin.forEach(file => {
                                const option = document.createElement('option');
                                option.value = file;
                                option.textContent = file;
                                sentenceSelect.appendChild(option);
                            });
                            console.log(`Added ${data.zin.length} options to the sentence dropdown`);
                        } else {
                            console.warn("No zin (sentence) animations found in response or invalid format");
                        }

                        glossSelect.innerHTML = '<option value="">Select Gloss...</option>'; // Placeholder
                        if (data.glos && Array.isArray(data.glos)) {
                            data.glos.forEach(file => {
                                const option = document.createElement('option');
                                option.value = file;
                                option.textContent = file;
                                glossSelect.appendChild(option);
                            });
                            console.log(`Added ${data.glos.length} options to the gloss dropdown`);
                        } else {
                            console.warn("No glos (gloss) animations found in response or invalid format");
                        }
                    } else {
                        console.error("Failed to fetch animation list:", data.error || "Unknown error");
                    }
                } catch (error) {
                    console.error("Error fetching animation list:", error);
                    // Show error in UI for better visibility
                    const sentenceSelect = document.getElementById('sentenceAnimation');
                    const glossSelect = document.getElementById('insertGlossAnimation');
                    
                    sentenceSelect.innerHTML = '<option value="">Error loading animations</option>';
                    glossSelect.innerHTML = '<option value="">Error loading animations</option>';
                    
                    // Create error message on the page
                    const errorDiv = document.createElement('div');
                    errorDiv.style.color = 'red';
                    errorDiv.style.padding = '10px';
                    errorDiv.style.backgroundColor = 'rgba(255,0,0,0.1)';
                    errorDiv.style.border = '1px solid red';
                    errorDiv.style.borderRadius = '5px';
                    errorDiv.style.marginTop = '10px';
                    errorDiv.innerHTML = `<strong>Error loading animations:</strong> ${error.message}<br>
                                         Check browser console for more details.<br>
                                         <small>Make sure PHP server is running and listAnimationFiles.php is accessible.</small>`;
                    
                    // Insert after animation controls
                    const animControls = document.getElementById('animationBlendingControls');
                    if (animControls && animControls.parentNode) {
                        animControls.parentNode.insertBefore(errorDiv, animControls.nextSibling);
                    } else {
                        document.body.appendChild(errorDiv);
                    }
                }
            }


            // --- End NEW Animation Loading and Management ---


            // If glossId is provided, fetch the corresponding animation file (Original logic, may need adjustment)
            // This part is now mostly handled by the new UI. We can remove or adapt it.
            /*
            if (glossId) {
                // ... original glossId fetching ...
            } else {
                // console.log("No glossId provided, using default animation or UI selection"); // Keep this log for now
            }
            */
            
            try {
                // First load the base model (meshes and textures) using our utility function
                const baseMeshAsset = await loadAssetMesh(scene, "", baseModelUrl, false);
                window.globalBaseMeshAsset = baseMeshAsset; // Make base model asset globally available
                
                // Store references to important parts of the base model
                const baseMeshes = baseMeshAsset.fetched.meshes;
                const baseSkeleton = baseMeshAsset.skeletons[0]; // Assuming there's a skeleton
                
                // UPDATED: Apply new default rotation with X at -90 degrees and Y at 180 degrees
                const defaultRotationX = -Math.PI/2; // -90 degrees in radians
                const defaultRotationY = Math.PI;    // 180 degrees in radians
                
                if (baseMeshAsset.root) {
                    // Apply rotation to the model with new default values
                    baseMeshAsset.root.rotation = new BABYLON.Vector3(defaultRotationX, defaultRotationY, 0);
                    console.log("Model rotated with new defaults");
                } else if (baseMeshAsset.god) {
                    // If root is not available but god (top-level node) is, rotate that instead
                    baseMeshAsset.god.rotation = new BABYLON.Vector3(defaultRotationX, defaultRotationY, 0);
                    console.log("Model rotated with new defaults using god node");
                } else {
                    // Last resort: try rotating all top-level meshes
                    baseMeshes.filter(mesh => !mesh.parent).forEach(mesh => {
                        mesh.rotation = new BABYLON.Vector3(defaultRotationX, defaultRotationY, 0);
                    });
                    console.log("Model rotated with new defaults using top-level meshes");
                }
                
                // Store a reference to the rotatable node for later use with rotation controls
                let rotatableNode;
                if (baseMeshAsset.root) {
                    rotatableNode = baseMeshAsset.root;
                } else if (baseMeshAsset.god) {
                    rotatableNode = baseMeshAsset.god;
                } else {
                    // If no hierarchical node is available, create a parent node for all top-level meshes
                    rotatableNode = new BABYLON.TransformNode("avatarRoot", scene);
                    baseMeshes.filter(mesh => !mesh.parent).forEach(mesh => {
                        mesh.parent = rotatableNode;
                        
                        // Apply rotation to the parent node
                        rotatableNode.rotation = new BABYLON.Vector3(defaultRotationX, defaultRotationY, 0);
                    });
                }
                
                // Find base mesh that has morph targets (if any)
                const baseMorphMeshes = baseMeshes.filter(mesh => mesh.morphTargetManager);
                
                console.log(`Base model loaded with ${baseMeshAsset.morphTargetManagers.length} morph target managers`);
                console.log(`Found ${baseMorphMeshes.length} meshes with morph targets`);
                
                // Load animation model using the dynamically determined URL
                console.log("Loading animation model:", animModelUrl);
                
                // Extract path and filename from animModelUrl
                const animUrlParts = animModelUrl.split('/');
                const animFileName = animUrlParts.pop();
                const animPath = animUrlParts.join('/') + '/';
                
                // Show loading indicator or message
                // const loadingText = new BABYLON.GUI.TextBlock();
                // loadingText.text = "Loading animation...";
                // loadingText.color = "black";
                // loadingText.fontSize = 24;
                // Add to GUI if needed
                
                // Now load the animation model directly
                // const animModelResult = await BABYLON.SceneLoader.ImportMeshAsync("", animPath, animFileName, scene);
                
                // Hide loading indicator
                // loadingText.isVisible = false;
                
                // console.log(`Animation model loaded with ${animModelResult.animationGroups.length} animation groups`);
                
                // Position animation model away from view temporarily
                // animModelResult.meshes.forEach(mesh => { // This was for the initial single anim load, not needed for dynamic loading
                //     if (mesh.id !== "__root__") {
                //         mesh.position.y = -1000; // Move far below view
                //     }
                // });
                
                // Create retargeted animation groups
                // const retargetedAnimations = []; // This was for the initial single anim load
                
                // For each animation group, retarget it to the base model
                // This initial loading block for a single animation specified by animModelUrl is no longer the primary way animations are loaded.
                // Animations are now loaded on demand via loadAnimationByName.
                // We can comment out or remove this block if no default animation is needed at startup based on animModelUrl.
                /*
                for(let i = 0; i < animModelResult.animationGroups.length; i++) {
                    const animGroup = animModelResult.animationGroups[i];
                    console.log(`Retargeting animation group: ${animGroup.name}`);
                    
                    const retargetedAnim = retargetAnimWithBlendshapes(
                        baseMeshAsset, 
                        animGroup, 
                        `Retargeted_${animGroup.name}`
                    );
                    
                    if(retargetedAnim) {
                        retargetedAnimations.push(retargetedAnim);
                        console.log(`Successfully retargeted animation: ${retargetedAnim.name}`);
                    }
                }
                */
                
                // Hide the animation model after retargeting (if it was loaded initially)
                // animModelResult.meshes.forEach(mesh => { // Also part of initial single anim load
                //    mesh.isVisible = false;
                // });
                
                // Create main control panel
                const controlPanel = document.createElement('div');
                controlPanel.className = 'control-panel';
                controlPanel.style.top = '10px';
                controlPanel.style.left = '10px';
                document.body.appendChild(controlPanel);
                
                // Add play/pause button
                const playButton = document.createElement('button');
                playButton.id = 'globalPlayPauseButton'; // Assign an ID
                playButton.textContent = 'Pause'; // Initial state, assuming something plays
                playButton.style.padding = '5px 10px';
                playButton.style.borderRadius = '3px';
                controlPanel.appendChild(playButton);
                
                // Add rotation control panel
                const rotationControlsContainer = document.createElement('div');
                rotationControlsContainer.className = 'rotation-controls';
                controlPanel.appendChild(rotationControlsContainer);
                
                // Function to create rotation controls for each axis
                function createRotationControl(axis, initialValue, min, max) {
                    const controlDiv = document.createElement('div');
                    controlDiv.className = 'rotation-control';
                    
                    const label = document.createElement('label');
                    label.textContent = axis;
                    controlDiv.appendChild(label);
                    
                    const slider = document.createElement('input');
                    slider.type = 'range';
                    slider.min = min;
                    slider.max = max;
                    slider.step = 1;
                    slider.value = initialValue;
                    controlDiv.appendChild(slider);
                    
                    const valueDisplay = document.createElement('span');
                    valueDisplay.textContent = `${initialValue}°`;
                    controlDiv.appendChild(valueDisplay);
                    
                    // Update rotation on slider change
                    slider.addEventListener('input', function() {
                        const degrees = parseFloat(this.value);
                        valueDisplay.textContent = `${degrees}°`;
                        
                        // Convert to radians and update the appropriate rotation axis
                        const radians = BABYLON.Tools.ToRadians(degrees);
                        if (axis === 'X') {
                            rotatableNode.rotation.x = radians;
                        } else if (axis === 'Y') {
                            rotatableNode.rotation.y = radians;
                        } else if (axis === 'Z') {
                            rotatableNode.rotation.z = radians;
                        }
                    });
                    
                    return controlDiv;
                }
                
                // UPDATED: Add rotation controls with new initial values
                // X at -90 degrees, Y at 180 degrees, and Z at 0 degrees
                rotationControlsContainer.appendChild(createRotationControl('X', -90, -180, 180));
                rotationControlsContainer.appendChild(createRotationControl('Y', 180, -180, 180));
                rotationControlsContainer.appendChild(createRotationControl('Z', 0, -180, 180));
                
                // Store current animation (original logic, will be managed by new system)
                // let currentAnimation = null; 
                
                // Set up animation playback (original logic, largely replaced)
                /*
                if (retargetedAnimations.length > 0) {
                    // Start the first animation by default
                    currentAnimation = retargetedAnimations[0];
                    currentAnimation.start(true); // Start and loop
                    
                    // Set up event listener for play/pause button
                    playButton.addEventListener('click', function() { ... }); // This listener will be replaced
                } else { ... }
                */

                // NEW: Event listener for the global play/pause button
                document.getElementById('globalPlayPauseButton').addEventListener('click', function() {
                    // UPDATED Global Play/Pause Logic
                    if (window.activeAnimForGlobalPlayPause && window.activeAnimForGlobalPlayPause.isPlaying) {
                        window.activeAnimForGlobalPlayPause.pause();
                        this.textContent = 'Play';
                        // If gloss is also playing independently and was not the primary active one, pause it too.
                        if (window.currentGlossAnim && window.currentGlossAnim !== window.activeAnimForGlobalPlayPause && window.currentGlossAnim.isPlaying) {
                            window.currentGlossAnim.pause();
                        }
                    } else if (window.activeAnimForGlobalPlayPause) {
                        window.activeAnimForGlobalPlayPause.play();
                        this.textContent = 'Pause';
                        // If gloss was also paused and is meant to be playing, resume it.
                        if (window.currentGlossAnim && window.currentGlossAnim !== window.activeAnimForGlobalPlayPause && !window.currentGlossAnim.isPlaying && window.glossStopTimer) {
                            // This condition is tricky: only resume gloss if it was supposed to be active.
                            // A simpler approach might be to just let the main active animation control the button.
                            // For now, let's assume play on activeAnimForGlobalPlayPause resumes it.
                        }
                    } else {
                        // If no active sequence, play the selected original sentence (existing logic)
                        const selectedSentenceFile = document.getElementById('sentenceAnimation').value;
                        if (selectedSentenceFile && window.allRetargetedAnimations.zin[selectedSentenceFile]) {
                             const sentenceAnim = window.allRetargetedAnimations.zin[selectedSentenceFile];
                             if (window.currentBaseAnim) window.currentBaseAnim.stop();
                             if (window.currentGlossAnim) window.currentGlossAnim.stop();
                             clearTimeout(window.glossInsertionTimer);
                             clearTimeout(window.glossStopTimer);

                             sentenceAnim.play(true); // Play and loop
                             window.currentBaseAnim = sentenceAnim;
                             window.activeAnimForGlobalPlayPause = sentenceAnim;
                             window.currentGlossAnim = null;
                             this.textContent = 'Pause';
                        }
                    }
                });


                // NEW: Event listeners for blending controls
                document.getElementById('playOriginalSentenceButton').addEventListener('click', async () => {
                    const selectedSentenceFile = document.getElementById('sentenceAnimation').value;
                    if (!selectedSentenceFile) { alert("Please select a base sentence."); return; }

                    const sentenceAnim = await loadAnimationByName(selectedSentenceFile, 'zin', scene, window.globalBaseMeshAsset);
                    if (sentenceAnim) {
                        if (window.currentBaseAnim) window.currentBaseAnim.stop();
                        if (window.currentGlossAnim) window.currentGlossAnim.stop();
                        clearTimeout(window.glossInsertionTimer);
                        clearTimeout(window.glossStopTimer);

                        sentenceAnim.reset();
                        sentenceAnim.play(true); // Play and loop
                        window.currentBaseAnim = sentenceAnim;
                        window.activeAnimForGlobalPlayPause = sentenceAnim;
                        window.currentGlossAnim = null;
                        document.getElementById('globalPlayPauseButton').textContent = 'Pause';
                    } else {
                        alert("Failed to load selected sentence animation.");
                    }
                });

                document.getElementById('applyBlendButton').addEventListener('click', async () => {
                    // --- NEW Blending Logic --- 
                    const baseAnimFile = document.getElementById('sentenceAnimation').value;
                    const glossAnimFile = document.getElementById('insertGlossAnimation').value;
                    const glossInsertionTime = parseFloat(document.getElementById('baseCutStartTime').value); // Renamed ID
                    const glossStartTime = parseFloat(document.getElementById('glossPlayStartTime').value);
                    let glossEndTime = parseFloat(document.getElementById('glossPlayEndTime').value);
                    const glossBlendDuration = parseFloat(document.getElementById('blendDuration').value);
                    const blendBalance = parseFloat(document.getElementById('blendBalance').value) || 0.5;

                    if (!baseAnimFile || !glossAnimFile) {
                        alert("Please select both a base sentence and a gloss animation.");
                        return;
                    }
                    if (isNaN(glossInsertionTime) || glossInsertionTime < 0) {
                        alert("Please enter a valid, non-negative gloss insertion time.");
                        return;
                    }
                    if (isNaN(glossStartTime) || glossStartTime < 0 || isNaN(glossEndTime) || glossEndTime < 0) {
                        alert("Please enter valid, non-negative start/end times for the gloss animation.");
                        return;
                    }
                    if (glossEndTime > 0 && glossEndTime < glossStartTime) {
                        alert("Gloss end time cannot be earlier than gloss start time (unless end time is 0 for full duration).");
                        return;
                    }
                    if (isNaN(glossBlendDuration) || glossBlendDuration <= 0) {
                        alert("Please enter a valid positive gloss blend duration (e.g., 0.1 - 0.5).");
                        return;
                    }

                    const baseAnim = await loadAnimationByName(baseAnimFile, 'zin', scene, window.globalBaseMeshAsset);
                    const glossAnim = await loadAnimationByName(glossAnimFile, 'glos', scene, window.globalBaseMeshAsset);

                    if (!baseAnim || !(baseAnim instanceof BABYLON.AnimationGroup) || typeof baseAnim.start !== 'function') {
                        alert("Failed to load base animation as a valid AnimationGroup. Check console.");
                        console.error("Loaded baseAnim is not valid:", baseAnim);
                        return;
                    }
                    if (!glossAnim || !(glossAnim instanceof BABYLON.AnimationGroup) || typeof glossAnim.start !== 'function') {
                        alert("Failed to load gloss animation as a valid AnimationGroup. Check console.");
                        console.error("Loaded glossAnim is not valid:", glossAnim);
                        return;
                    }

                    // Stop any currently playing animations and clear timers
                    if (window.currentBaseAnim) window.currentBaseAnim.stop();
                    if (window.currentGlossAnim) window.currentGlossAnim.stop();
                    clearTimeout(window.glossInsertionTimer);
                    clearTimeout(window.glossStopTimer);

                    window.currentBaseAnim = baseAnim;
                    window.currentGlossAnim = glossAnim;
                    window.activeAnimForGlobalPlayPause = baseAnim; // Base animation controls global play/pause initially
                    
                    // Store parameters for looping replay
                    window.animationParams = {
                        baseAnimFile,
                        glossAnimFile,
                        glossInsertionTime,
                        glossStartTime,
                        glossEndTime,
                        glossBlendDuration,
                        blendBalance
                    };

                    baseAnim.reset();
                    glossAnim.reset();

                    // Apply blend balance
                    if (typeof baseAnim.setWeightForAllAnimatables === 'function') {
                        baseAnim.setWeightForAllAnimatables(1.0 - blendBalance);
                    }
                    if (typeof glossAnim.setWeightForAllAnimatables === 'function') {
                        glossAnim.setWeightForAllAnimatables(blendBalance);
                    }

                    // Determine gloss playback range in frames
                    const glossFps = glossAnim.targetedAnimations[0]?.animation.framePerSecond || 30;
                    let glossPlayFromFrame = glossStartTime * glossFps;
                    let glossPlayToFrame = glossAnim.to; // Default to full gloss animation
                    if (glossEndTime > 0 && glossEndTime * glossFps < glossAnim.to) {
                        glossPlayToFrame = glossEndTime * glossFps;
                    }
                    if (glossPlayFromFrame >= glossPlayToFrame) {
                        alert("Gloss start time results in a start frame at or after the end frame. Please correct gloss segment times.");
                        return;
                    }
                    const glossDurationSeconds = (glossPlayToFrame - glossPlayFromFrame) / glossFps;

                    console.log(`Base: ${baseAnimFile}, Gloss: ${glossAnimFile}`);
                    console.log(`Gloss Insertion Time: ${glossInsertionTime}s`);
                    console.log(`Gloss Segment: ${glossStartTime}s to ${glossEndTime === 0 ? 'end' : glossEndTime + 's'} (Frames: ${glossPlayFromFrame} to ${glossPlayToFrame})`);
                    console.log(`Gloss Calculated Duration: ${glossDurationSeconds}s`);
                    console.log(`Gloss Blend Duration: ${glossBlendDuration}s`);
                    console.log(`Blend Balance: ${blendBalance}`);

                    // Function to schedule gloss animation within the base animation
                    function scheduleGlossAnimation() {
                        console.log("Scheduling gloss animation for next loop");
                        window.glossInsertionTimer = setTimeout(() => {
                            console.log(`Starting gloss animation: ${glossAnim.name} at ${new Date().toLocaleTimeString()}`);
                            if (typeof glossAnim.enableBlending === 'function') {
                                glossAnim.enableBlending(glossBlendDuration);
                            }
                            
                            // Apply blend balance
                            if (typeof glossAnim.setWeightForAllAnimatables === 'function') {
                                glossAnim.setWeightForAllAnimatables(blendBalance);
                            }
                            
                            glossAnim.start(false, 1.0, glossPlayFromFrame, glossPlayToFrame);
                            window.activeAnimForGlobalPlayPause = glossAnim; // Gloss takes over play/pause focus while active
                            console.log(`Gloss animation ${glossAnim.name} started, playing from frame ${glossPlayFromFrame} to ${glossPlayToFrame}.`);

                            // Schedule the gloss animation to stop blending out
                            window.glossStopTimer = setTimeout(() => {
                                console.log(`Stopping gloss animation: ${glossAnim.name} at ${new Date().toLocaleTimeString()}`);
                                glossAnim.stop(); // This should use the blending speed set by enableBlending to fade out
                                
                                // Revert global play/pause focus to base animation if it's still playing
                                if (window.currentBaseAnim && window.currentBaseAnim.isPlaying) {
                                    window.activeAnimForGlobalPlayPause = window.currentBaseAnim;
                                }
                            }, glossDurationSeconds * 1000);
                        }, glossInsertionTime * 1000);
                    }

                    // Start the base animation (looping this time)
                    baseAnim.start(true, 1.0, baseAnim.from, baseAnim.to);
                    document.getElementById('globalPlayPauseButton').textContent = 'Pause';
                    console.log("Base animation started with looping enabled");

                    // Schedule the first gloss animation
                    scheduleGlossAnimation();

                    // Handle looping by attaching an event to the animation group's onAnimationGroupEndObservable
                    baseAnim.onAnimationGroupEndObservable.add(() => {
                        console.log("Base animation loop complete, rescheduling gloss");
                        // Clear any pending timers to avoid overlapping schedules
                        clearTimeout(window.glossInsertionTimer);
                        clearTimeout(window.glossStopTimer);
                        
                        // Reset the gloss animation if it's still playing
                        if (window.currentGlossAnim && window.currentGlossAnim.isPlaying) {
                            window.currentGlossAnim.stop();
                        }
                        
                        // Schedule the gloss animation for the next loop
                        scheduleGlossAnimation();
                    });
                });

                // Fetch animation file lists and populate dropdowns
                await fetchAnimationFilesAndPopulateDropdowns();
                
                // Initial state for play button if nothing is playing by default
                if (!window.currentActiveAnimationGroupInSequence) {
                     document.getElementById('globalPlayPauseButton').textContent = 'Play';
                }


                // The rest of the setupScene function (camera, etc.)
                // Optional: Adjust camera target or position based on loaded model bounds
                const meshes = baseMeshes;
                if (meshes.length > 1) { // Exclude the ground/environment if any, focus on imported meshes
                    let min = new BABYLON.Vector3(Infinity, Infinity, Infinity);
                    let max = new BABYLON.Vector3(-Infinity, -Infinity, -Infinity);
                    meshes.forEach(mesh => {
                        if (mesh.getBoundingInfo()) {
                            let meshMin = mesh.getBoundingInfo().boundingBox.minimumWorld;
                            let meshMax = mesh.getBoundingInfo().boundingBox.maximumWorld;
                            min = BABYLON.Vector3.Minimize(min, meshMin);
                            max = BABYLON.Vector3.Maximize(max, meshMax);
                        }
                    });
                    const center = BABYLON.Vector3.Center(min, max);
                    camera.setTarget(center);

                    // Adjust camera radius based on model size
                    const size = max.subtract(min);
                    const maxDim = Math.max(size.x, size.y, size.z);
                    
                    // UPDATED: Set initial radius to a larger value for a more zoomed-out view
                    camera.radius = maxDim * 1.8; // Increased from maxDim * 1 to maxDim * 1.8

                    // FIX FOR CLIPPING: Modify zoom limits to allow much closer zooming
                    camera.lowerRadiusLimit = maxDim * 1; // Allow zooming VERY close (was maxDim * 1)
                    camera.upperRadiusLimit = maxDim * 2;   // Allow zooming out a bit more
                    
                    // Also make sure all meshes have their visibility distance range extended
                    meshes.forEach(mesh => {
                        if (mesh.visibility !== 0) {
                            mesh.alwaysSelectAsActiveMesh = true; // Prevent culling
                            
                            // Force update of bounding info to ensure proper visibility
                            if (mesh.getBoundingInfo()) {
                                mesh.refreshBoundingInfo(true);
                            }
                            
                            // Disable frustum clipping for this mesh
                            mesh.isNearGrabbable = true;
                            mesh.doNotSyncBoundingInfo = false;
                        }
                    });
                    
                    // FIX FOR CLIPPING: Change auto-rotate behavior to prevent zooming through the model
                    camera.checkCollisions = false;  // Disable collision checks which can affect zoom
                    camera.noRotationConstraint = true;  // Remove constraints that might affect rotation/zoom
                    
                    // --- Add Camera Rotation Angle Limits ---
                    // Alpha is horizontal rotation (around Y axis)
                    // Set the initial angle as the center of the allowed range
                    const initialAlpha = Math.PI / 2;  // Rotated 180 degrees to see front of model
                    const alphaRange = Math.PI / 6; // Allow 30 degrees of rotation in each direction
                    camera.lowerAlphaLimit = initialAlpha - alphaRange;
                    camera.upperAlphaLimit = initialAlpha + alphaRange;
                    
                    // Beta is vertical rotation (0 is top view, PI is bottom view)
                    // Set limits to prevent looking at the model from extreme angles
                    const initialBeta = Math.PI / 2.5;
                    const betaRange = Math.PI / 8; // Allow limited vertical rotation
                    camera.lowerBetaLimit = initialBeta - betaRange;
                    camera.upperBetaLimit = initialBeta + betaRange;

                    // Remove 3D Text (commented out)
                    /* 
                    const Writer = BABYLON.MeshWriter(scene, { scale: 1.0, defaultFont: "Arial" });
                    const textMesh = new Writer(
                        "Gebaar",
                        {
                            "anchor": "center",
                            "letter-height": maxDim * 0.2, // Scale text size relative to model
                            "color": "#1C3870", // Example color
                            "position": {
                                x: center.x, // Center horizontally with the model
                                y: center.y + maxDim * 0.6, // Position above the model's center
                                z: center.z - maxDim * 0.5  // Position behind the model
                            }
                        }
                    );
                    */
                }

            } catch (error) {
                console.error("Error loading model:", error);
            }

            return scene;
        };

        setupScene().then(scene => {
            engine.runRenderLoop(function () {
                if (scene) {
                    scene.render();
                }
            });
        });

        // Resize the engine on window resize
        window.addEventListener("resize", function () {
            engine.resize();
        });
    </script>
</body>
</html>

<script>
    // --- NEW Animation Blending Logic ---
    // These variables are now global within this script block's scope, 
    // or accessed via window if set elsewhere.
    let currentBaseAnimation = null;
    let currentGlossAnimation = null;
    let glossFadeInTimer = null;
    let glossFadeOutTimer = null;
    let glossStopTimer = null;

    let isPlaying = false; // Moved to script block scope
    let isTimelineDragging = false; // Moved to script block scope for hover logic and clip dragging state

    // window.currentBaseAnim, window.currentGlossAnim, window.glossInsertionTimer, window.glossStopTimer
    // are expected to be managed by the calling context if they are truly global.
    // For now, the local versions above will be used by these functions.
    // If they need to interact with the ones previously on window, that needs to be handled.

    async function stopGlossSequence() {
        console.log("[GlossSeq] Stopping gloss sequence and cleaning up resources.");
        clearTimeout(glossFadeInTimer);
        glossFadeInTimer = null;
        clearTimeout(glossFadeOutTimer);
        glossFadeOutTimer = null;
        clearTimeout(glossStopTimer);
        glossStopTimer = null;

        if (currentGlossAnimation) {
            console.log(`[GlossSeq] Stopping and disposing gloss animation: ${currentGlossAnimation.name}`);
            currentGlossAnimation.stop();
            if (typeof currentGlossAnimation.dispose === 'function') {
                currentGlossAnimation.dispose();
            }
            currentGlossAnimation = null;
        }
        if (currentBaseAnimation) {
            console.log(`[GlossSeq] Stopping and disposing base animation: ${currentBaseAnimation.name}`);
            currentBaseAnimation.stop();
            if (typeof currentBaseAnimation.dispose === 'function') {
                currentBaseAnimation.dispose();
            }
            currentBaseAnimation = null;
        }
        console.log("[GlossSeq] Cleanup complete.");
    }

    async function playGlossSequence(baseAnimFilename, glossAnimFilename, baseCutTime, glossDuration, blendSpeed) {
        console.log(`[GlossSeq] Attempting to play: Base=${baseAnimFilename}, Gloss=${glossAnimFilename}, Cut=${baseCutTime}s, GlossDur=${glossDuration}s, Blend=${blendSpeed}`);

        await stopGlossSequence(); // Clear any previous state and animations

        const targetMesh = window.loadedMeshes['glasses_guyV2'];
        if (!targetMesh || !targetMesh.skeleton) {
            console.error("[GlossSeq] Target mesh 'glasses_guyV2' or its skeleton not found.");
            alert("Target mesh 'glasses_guyV2' or its skeleton not found. Cannot play sequence.");
            return;
        }
        if (!window.scene) { // Use window.scene
            console.error("[GlossSeq] Babylon scene object is not available.");
            alert("Babylon scene object is not available. Cannot play sequence.");
            return;
        }
        // Ensure 장면FPS is accessible, assuming it's global or on window
        let fpsToUse = typeof 장면FPS !== 'undefined' && 장면FPS > 0 ? 장면FPS : (typeof window.장면FPS !== 'undefined' && window.장면FPS > 0 ? window.장면FPS : 60);
        if (fpsToUse === 60 && (typeof 장면FPS === 'undefined' || 장면FPS <= 0) && (typeof window.장면FPS === 'undefined' || window.장면FPS <=0)) {
             console.warn("[GlossSeq] 장면FPS is not defined or invalid globally or locally. Falling back to 60 FPS.");
        }


        try {
            console.log(`[GlossSeq] Loading base animation: ${baseAnimFilename}`);
            // Use window.scene in the call
            currentBaseAnimation = await window.animationPlayer.loadAnimation(baseAnimFilename, 'zin', window.scene, 'glasses_guyV2', false, false, 1.0);
            if (!currentBaseAnimation || typeof currentBaseAnimation.start !== 'function') {
                console.error(`[GlossSeq] Failed to load base animation or animation group is invalid: ${baseAnimFilename}`);
                alert(`Failed to load base animation: ${baseAnimFilename}`);
                await stopGlossSequence();
                return;
            }
            currentBaseAnimation.name = baseAnimFilename;
            currentBaseAnimation.stop();

            console.log(`[GlossSeq] Loading gloss animation: ${glossAnimFilename}`);
            // Use window.scene in the call
            currentGlossAnimation = await window.animationPlayer.loadAnimation(glossAnimFilename, 'glos', window.scene, 'glasses_guyV2', false, false, 1.0);
            if (!currentGlossAnimation || typeof currentGlossAnimation.start !== 'function') {
                console.error(`[GlossSeq] Failed to load gloss animation or animation group is invalid: ${glossAnimFilename}`);
                alert(`Failed to load gloss animation: ${glossAnimFilename}`);
                await stopGlossSequence();
                return;
            }
            currentGlossAnimation.name = glossAnimFilename;
            currentGlossAnimation.stop();

            console.log("[GlossSeq] Animations loaded successfully.");

            const baseCutFrame = Math.max(0, baseCutTime * fpsToUse);
            const glossPlayToFrame = Math.max(0, glossDuration * fpsToUse);
            
            if (typeof currentBaseAnimation.to !== 'number' || typeof currentGlossAnimation.to !== 'number') {
                console.error("[GlossSeq] Animation groups 'to' property is not valid.");
                alert("Loaded animations have invalid metadata. Cannot play sequence.");
                await stopGlossSequence();
                return;
            }

            console.log(`[GlossSeq] Part 1: Base '${currentBaseAnimation.name}' from 0 to ${baseCutFrame} (Time: ${baseCutTime}s)`);
            if (baseCutTime > 0 && baseCutFrame <= currentBaseAnimation.to) {
                    currentBaseAnimation.start(false, 1.0, 0, baseCutFrame);
            } else if (baseCutTime <= 0) {
                console.log("[GlossSeq] Base cut time is 0 or negative, skipping Part 1 of base animation.");
            } else { // baseCutFrame > currentBaseAnimation.to
                console.warn(`[GlossSeq] baseCutTime ${baseCutTime}s (${baseCutFrame} frames) is beyond base animation duration (${currentBaseAnimation.to / fpsToUse}s). Playing full base animation for Part 1.`);
                currentBaseAnimation.start(false, 1.0, 0, currentBaseAnimation.to);
            }
            // Ensure window.animationPlayer is accessible
            if (window.animationPlayer) {
                window.animationPlayer.currentAnimation = currentBaseAnimation;
                window.animationPlayer.isPlaying = true;
            }
            if (typeof updatePlayPauseButton === 'function') updatePlayPauseButton(true);

            glossFadeInTimer = setTimeout(() => {
                if (!currentBaseAnimation || !currentGlossAnimation) {
                    console.log("[GlossSeq] Animations disposed before gloss fade-in. Aborting Part 2.");
                    return;
                }
                console.log(`[GlossSeq] Part 2: Blending Gloss '${currentGlossAnimation.name}' (Duration: ${glossDuration}s, Target Frames: ${glossPlayToFrame})`);
                
                if (typeof currentGlossAnimation.enableBlending === 'function') {
                    currentGlossAnimation.enableBlending(blendSpeed);
                } else {
                    console.warn(`[GlossSeq] currentGlossAnimation.enableBlending is not a function for ${currentGlossAnimation.name}`);
                }
                
                if (glossDuration > 0) {
                    currentGlossAnimation.start(false, 1.0, 0, Math.min(glossPlayToFrame, currentGlossAnimation.to));
                } else {
                        console.log("[GlossSeq] Gloss duration is 0 or negative, skipping gloss playback.");
                }

                glossFadeOutTimer = setTimeout(() => {
                    if (!currentBaseAnimation || !currentGlossAnimation) {
                        console.log("[GlossSeq] Animations disposed before base resume. Aborting Part 3.");
                        return;
                    }
                    console.log(`[GlossSeq] Part 3: Blending back to Base '${currentBaseAnimation.name}' from ${baseCutFrame}`);
                    
                    currentGlossAnimation.stop();

                    if (typeof currentBaseAnimation.enableBlending === 'function') {
                        currentBaseAnimation.enableBlending(blendSpeed);
                    } else {
                        console.warn(`[GlossSeq] currentBaseAnimation.enableBlending is not a function for ${currentBaseAnimation.name}`);
                    }

                    const resumeBaseFromFrame = baseCutFrame;
                    if (resumeBaseFromFrame < currentBaseAnimation.to) {
                        currentBaseAnimation.start(false, 1.0, resumeBaseFromFrame, currentBaseAnimation.to);
                    } else {
                        console.log("[GlossSeq] Base animation already played past cut frame or to its end. Not resuming second part.");
                    }
                    
                    let isPlayingAfterResume = (resumeBaseFromFrame < currentBaseAnimation.to);
                    if (window.animationPlayer) {
                        window.animationPlayer.currentAnimation = currentBaseAnimation;
                        window.animationPlayer.isPlaying = isPlayingAfterResume;
                    }
                    if (typeof updatePlayPauseButton === 'function') updatePlayPauseButton(isPlayingAfterResume);

                    const remainingBaseDurationMs = Math.max(0, (currentBaseAnimation.to - resumeBaseFromFrame) / fpsToUse) * 1000;
                    
                    if (!isPlayingAfterResume || remainingBaseDurationMs <=0 ) {
                        console.log("[GlossSeq] No remaining base animation to play or duration is zero. Scheduling immediate cleanup.");
                        stopGlossSequence();
                        if (window.animationPlayer) {
                            window.animationPlayer.currentAnimation = null;
                            window.animationPlayer.isPlaying = false;
                        }
                        if (typeof updatePlayPauseButton === 'function') updatePlayPauseButton(false);
                        return; 
                    }

                    glossStopTimer = setTimeout(() => {
                        console.log("[GlossSeq] Sequence finished. Final cleanup.");
                        stopGlossSequence(); 
                        if (window.animationPlayer) {
                            window.animationPlayer.currentAnimation = null;
                            window.animationPlayer.isPlaying = false;
                        }
                        if (typeof updatePlayPauseButton === 'function') updatePlayPauseButton(false);
                    }, remainingBaseDurationMs);

                }, Math.max(0, glossDuration * 1000));

            }, Math.max(0, baseCutTime * 1000));

        } catch (error) {
            console.error("[GlossSeq] Error during playGlossSequence:", error);
            alert(`Error playing sequence: ${error.message}. Check console.`);
            await stopGlossSequence();
            if (window.animationPlayer) {
                window.animationPlayer.currentAnimation = null;
                window.animationPlayer.isPlaying = false;
            }
            if (typeof updatePlayPauseButton === 'function') updatePlayPauseButton(false);
        }
    }

    // --- Timeline Editor Functionality ---
    document.addEventListener('DOMContentLoaded', function() {
        // Timeline state variables
        let timelineZoomLevel = 1;
        // isPlaying and isTimelineDragging are now accessed from the outer script block scope
        let currentTime = 0;
        window.maxTimeVisible = 10; // Default max time visible in seconds (make it global for drag handlers)
        window.baseAnimDuration = 0; // Make global
        window.glossAnimDuration = 0; // Make global
        // let isPlaying = false; // REMOVED from here
        // let isTimelineDragging = false; // REMOVED from here
        let dragTrackType = null; // 'base' or 'gloss'
        let animationFrameId = null;
        let lastTimestampMS = 0;
        
        // DOM elements
        const timelineEditor = document.getElementById('timelineEditor');
        const timelinePlayPauseBtn = document.getElementById('timelinePlayPauseBtn');
        const timelineResetBtn = document.getElementById('timelineResetBtn');
        const timelineTimeDisplay = document.getElementById('timelineTimeDisplay');
        const timelineZoomOutBtn = document.getElementById('timelineZoomOutBtn');
        const timelineZoomInBtn = document.getElementById('timelineZoomInBtn');
        const baseAnimTrack = document.getElementById('baseAnimTrack');
        const glossAnimTrack = document.getElementById('glossAnimTrack');
        const basePlayhead = document.getElementById('basePlayhead');
        const glossPlayhead = document.getElementById('glossPlayhead');
        const glossInsertionMarker = document.getElementById('glossInsertionMarker');
        const timelineMarkers = document.getElementById('timelineMarkers');
        
        // Timeline tracks - make these global for the drag handlers
        window.baseCutStartInput = document.getElementById('baseCutStartTime');
        window.glossPlayStartInput = document.getElementById('glossPlayStartTime');
        window.glossPlayEndInput = document.getElementById('glossPlayEndTime');
        
        // Initialize timeline
        updateTimelineMarkers();
        
        // Connect to the animation selection dropdowns
        const sentenceAnimSelect = document.getElementById('sentenceAnimation');
        const glossAnimSelect = document.getElementById('insertGlossAnimation');
        
        sentenceAnimSelect.addEventListener('change', async function() {
            const selectedBaseAnim = sentenceAnimSelect.value;
            if (!selectedBaseAnim) return;
            
            // Load animation duration
            if (window.currentBaseAnim) {
                window.currentBaseAnim.stop();
            }
            
            try {
                const baseAnim = await loadAnimationByName(
                    selectedBaseAnim, 
                    'zin', 
                    window.scene, 
                    window.globalBaseMeshAsset
                );
                
                if (baseAnim) {
                    const fps = baseAnim.targetedAnimations[0]?.animation.framePerSecond || 30;
                    baseAnimDuration = baseAnim.to / fps;
                    
                    // Visually update timeline
                    updateBaseTrack();
                    resetTimeline();
                    
                    console.log(`[Timeline] Base animation duration: ${baseAnimDuration}s`);
                }
            } catch (error) {
                console.error('[Timeline] Error loading base animation duration:', error);
            }
        });
        
        glossAnimSelect.addEventListener('change', async function() {
            const selectedGlossAnim = glossAnimSelect.value;
            if (!selectedGlossAnim) return;
            
            // Load animation duration
            if (window.currentGlossAnim) {
                window.currentGlossAnim.stop();
            }
            
            try {
                const glossAnim = await loadAnimationByName(
                    selectedGlossAnim, 
                    'glos', 
                    window.scene, 
                    window.globalBaseMeshAsset
                );
                
                if (glossAnim) {
                    const fps = glossAnim.targetedAnimations[0]?.animation.framePerSecond || 30;
                    glossAnimDuration = glossAnim.to / fps;
                    
                    // Visually update timeline
                    updateGlossTrack();
                    
                    // Set default end time to full duration if currently 0
                    if (parseFloat(glossPlayEndInput.value) === 0) {
                        glossPlayEndInput.value = glossAnimDuration.toFixed(1);
                    }
                    
                    console.log(`[Timeline] Gloss animation duration: ${glossAnimDuration}s`);
                }
            } catch (error) {
                console.error('[Timeline] Error loading gloss animation duration:', error);
            }
        });
        
        // Timeline input fields connection
        baseCutStartInput.addEventListener('input', function() {
            const value = parseFloat(baseCutStartInput.value);
            if (!isNaN(value)) {
                updateGlossInsertionMarker(value);
            }
        });
        
        glossPlayStartInput.addEventListener('input', updateGlossTrack);
        glossPlayEndInput.addEventListener('input', updateGlossTrack);
        
        // Timeline playback controls
        timelinePlayPauseBtn.addEventListener('click', function() {
            togglePlayback();
        });
        
        timelineResetBtn.addEventListener('click', function() {
            resetTimeline();
        });
        
        // Timeline zoom controls
        timelineZoomInBtn.addEventListener('click', function() {
            timelineZoomLevel = Math.min(timelineZoomLevel * 1.5, 5);
            maxTimeVisible = 10 / timelineZoomLevel;
            updateTimelineMarkers();
            updateBaseTrack();
            updateGlossTrack();
            updateGlossInsertionMarker(parseFloat(baseCutStartInput.value));
        });
        
        timelineZoomOutBtn.addEventListener('click', function() {
            timelineZoomLevel = Math.max(timelineZoomLevel / 1.5, 0.25);
            maxTimeVisible = 10 / timelineZoomLevel;
            updateTimelineMarkers();
            updateBaseTrack();
            updateGlossTrack();
            updateGlossInsertionMarker(parseFloat(baseCutStartInput.value));
        });
        
        // Timeline track interaction
        // Get direct references to the timeline tracks using appropriate selectors
        const baseTrack = document.querySelector('#timelineEditor .timeline-track:nth-child(1)');
        const glossTrack = document.querySelector('#timelineEditor .timeline-track:nth-child(2)');
        
        if (baseTrack) {
            console.log('[Timeline] Successfully found base track element');
            baseTrack.addEventListener('mousedown', function(event) {
                isTimelineDragging = true;
                dragTrackType = 'base';
                handleTimelineDrag(event);
            });
        } else {
            console.error('[Timeline] Failed to find base track element');
        }
        
        if (glossTrack) {
            console.log('[Timeline] Successfully found gloss track element');
            glossTrack.addEventListener('mousedown', function(event) {
                isTimelineDragging = true;
                dragTrackType = 'gloss';
                handleTimelineDrag(event);
            });
        } else {
            console.error('[Timeline] Failed to find gloss track element');
        }
        
        document.addEventListener('mousemove', function(event) {
            if (isTimelineDragging) {
                handleTimelineDrag(event);
            }
        });
        
        document.addEventListener('mouseup', function() {
            isTimelineDragging = false;
            dragTrackType = null;
        });
        
        // Timeline utility functions
        function togglePlayback() {
            isPlaying = !isPlaying;
            
            if (isPlaying) {
                timelinePlayPauseBtn.textContent = 'Pause';
                lastTimestampMS = performance.now();
                
                // Start animations from current timeline position
                if (window.currentBaseAnim) {
                    const fps = window.currentBaseAnim.targetedAnimations[0]?.animation.framePerSecond || 30;
                    const startFrame = currentTime * fps;
                    window.currentBaseAnim.start(true, 1.0, startFrame, window.currentBaseAnim.to);
                    window.activeAnimForGlobalPlayPause = window.currentBaseAnim;
                    document.getElementById('globalPlayPauseButton').textContent = 'Pause';
                }
                
                // Sync gloss animation if insertion time is reached
                const glossInsertTime = parseFloat(baseCutStartInput.value);
                if (window.currentGlossAnim && currentTime >= glossInsertTime) {
                    const timeSinceInsertion = currentTime - glossInsertTime;
                    const glossStartTime = parseFloat(glossPlayStartInput.value);
                    const totalStartOffset = glossStartTime + timeSinceInsertion;
                    
                    const fps = window.currentGlossAnim.targetedAnimations[0]?.animation.framePerSecond || 30;
                    const startFrame = totalStartOffset * fps;
                    
                    let endFrame;
                    const glossEndTime = parseFloat(glossPlayEndInput.value);
                    if (glossEndTime > 0) {
                        endFrame = glossEndTime * fps;
                    } else {
                        endFrame = window.currentGlossAnim.to;
                    }
                    
                    if (startFrame < endFrame) {
                        window.currentGlossAnim.start(true, 1.0, startFrame, endFrame);
                    }
                }
                
                animationFrameId = requestAnimationFrame(updateTimeline);
            } else {
                timelinePlayPauseBtn.textContent = 'Play';
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                
                // Pause both animations
                if (window.currentBaseAnim && window.currentBaseAnim.isPlaying) {
                    window.currentBaseAnim.pause();
                }
                if (window.currentGlossAnim && window.currentGlossAnim.isPlaying) {
                    window.currentGlossAnim.pause();
                }
                document.getElementById('globalPlayPauseButton').textContent = 'Play';
            }
        }
        
        function updateTimeline(timestamp) {
            const deltaTime = timestamp - lastTimestampMS;
            lastTimestampMS = timestamp;
            
            // Update current time
            currentTime += deltaTime / 1000;
            
            // Update playheads
            updatePlayheadPositions();
            
            // Check if we need to start gloss animation
            const glossInsertTime = parseFloat(baseCutStartInput.value);
            const glossPlayStartTime = parseFloat(glossPlayStartInput.value);
            const glossPlayEndTime = parseFloat(glossPlayEndInput.value) || glossAnimDuration;
            
            if (window.currentBaseAnim && window.currentGlossAnim) {
                // Check if we just crossed the insertion point
                if (currentTime >= glossInsertTime && 
                    currentTime < glossInsertTime + 0.1 && // Small window to catch the transition
                    !window.currentGlossAnim.isPlaying) {
                    
                    // Start gloss animation
                    console.log('[Timeline] Starting gloss animation at insertion point');
                    const fps = window.currentGlossAnim.targetedAnimations[0]?.animation.framePerSecond || 30;
                    const startFrame = glossPlayStartTime * fps;
                    const endFrame = glossPlayEndTime > 0 ? glossPlayEndTime * fps : window.currentGlossAnim.to;
                    
                    if (typeof window.currentGlossAnim.enableBlending === 'function') {
                        window.currentGlossAnim.enableBlending(parseFloat(document.getElementById('blendDuration').value));
                    }
                    window.currentGlossAnim.start(true, 1.0, startFrame, endFrame);
                }
                
                // Check if gloss animation should end
                const glossEndTimestamp = glossInsertTime + (glossPlayEndTime - glossPlayStartTime);
                if (currentTime >= glossEndTimestamp && 
                    window.currentGlossAnim.isPlaying) {
                    
                    console.log('[Timeline] Stopping gloss animation at end time');
                    window.currentGlossAnim.stop();
                }
            }
            
            // Loop if we hit the end of base animation
            if (baseAnimDuration > 0 && currentTime >= baseAnimDuration) {
                currentTime = 0;
                
                // Restart base animation
                if (window.currentBaseAnim) {
                    window.currentBaseAnim.start(true, 1.0, 0, window.currentBaseAnim.to);
                }
            }
            
            if (isPlaying) {
                animationFrameId = requestAnimationFrame(updateTimeline);
            }
        }
        
        function updatePlayheadPositions() {
            // Update time display
            const minutes = Math.floor(currentTime / 60);
            const seconds = Math.floor(currentTime % 60);
            const milliseconds = Math.floor((currentTime % 1) * 1000);
            timelineTimeDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${milliseconds.toString().padStart(3, '0')}`;
            
            // Calculate positions
            const positionPercent = (currentTime / maxTimeVisible) * 100;
            const cappedPosition = Math.min(positionPercent, 100); // Cap at 100%
            
            // Update base playhead
            basePlayhead.style.left = `${cappedPosition}%`;
            
            // Update gloss playhead if in view
            const glossInsertTime = parseFloat(baseCutStartInput.value);
            const glossStartTime = parseFloat(glossPlayStartInput.value);
            const glossTimeOffset = currentTime - glossInsertTime;
            
            if (glossTimeOffset >= 0) {
                const glossPosition = ((glossStartTime + glossTimeOffset) / maxTimeVisible) * 100;
                glossPlayhead.style.left = `${Math.min(glossPosition, 100)}%`;
                glossPlayhead.style.display = 'block';
            } else {
                glossPlayhead.style.display = 'none';
            }
        }
        
        function updateTimelineMarkers() {
            timelineMarkers.innerHTML = '';
            
            const majorMarkerInterval = determineMarkerInterval(maxTimeVisible);
            const minorMarkerCount = 4; // Number of minor markers between major markers
            
            for (let time = 0; time <= maxTimeVisible; time += majorMarkerInterval / minorMarkerCount) {
                const marker = document.createElement('div');
                marker.className = 'timeline-time-marker';
                
                const isMajorMarker = Math.abs(time % majorMarkerInterval) < 0.001;
                
                marker.style.left = `${(time / maxTimeVisible) * 100}%`;
                marker.style.height = isMajorMarker ? '10px' : '5px';
                
                if (isMajorMarker) {
                    const label = document.createElement('div');
                    label.className = 'timeline-time-label';
                    label.textContent = formatTime(time);
                    label.style.left = `${(time / maxTimeVisible) * 100}%`;
                    timelineMarkers.appendChild(label);
                }
                
                timelineMarkers.appendChild(marker);
            }
        }
        
        function determineMarkerInterval(visibleDuration) {
            if (visibleDuration <= 2) return 0.5;
            if (visibleDuration <= 5) return 1;
            if (visibleDuration <= 10) return 2;
            if (visibleDuration <= 30) return 5;
            if (visibleDuration <= 60) return 10;
            if (visibleDuration <= 300) return 30;
            return 60;
        }
        
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            if (mins > 0) {
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            }
            return `${secs}s`;
        }
        
        function handleTimelineDrag(event) {
            const trackRect = baseTrack.getBoundingClientRect();
            const trackWidth = trackRect.width;
            const relativeX = Math.max(0, Math.min(event.clientX - trackRect.left, trackWidth));
            const timePosition = (relativeX / trackWidth) * maxTimeVisible;
            
            currentTime = Math.max(0, timePosition);
            
            // Update UI
            updatePlayheadPositions();
            
            // If actively playing, update animation positions
            if (window.currentBaseAnim) {
                const fps = window.currentBaseAnim.targetedAnimations[0]?.animation.framePerSecond || 30;
                const frame = currentTime * fps;
                
                if (!isPlaying) {
                    // In scrubbing mode, use goToFrame for precise positioning
                    if (typeof window.currentBaseAnim.goToFrame === 'function') {
                        window.currentBaseAnim.goToFrame(frame);
                    } else {
                        // Fallback if goToFrame doesn't exist
                        window.currentBaseAnim.reset();
                        window.currentBaseAnim.start(false, 1.0, 0, window.currentBaseAnim.to);
                        window.currentBaseAnim.pause();
                        // Hack to position animation by weight adjustment - not optimal but works
                        window.currentBaseAnim._speedRatio = 999999;
                        window.currentBaseAnim.speedRatio = 0;
                        window.currentBaseAnim._normalize(frame);
                    }
                }
                
                // Update form input for gloss insertion point
                if (dragTrackType === 'base') {
                    baseCutStartInput.value = currentTime.toFixed(1);
                    updateGlossInsertionMarker(currentTime);
                }
            }
            
            if (window.currentGlossAnim && dragTrackType === 'gloss') {
                // When dragging gloss track, adjust gloss start/end times
                // This is a bit more complex as we need to calculate relative to insertion point
                const glossInsertTime = parseFloat(baseCutStartInput.value);
                const relativeGlossTime = Math.max(0, timePosition - glossInsertTime);
                
                glossPlayStartInput.value = relativeGlossTime.toFixed(1);
                updateGlossTrack();
            }
        }
        
        function updateBaseTrack() {
            if (baseAnimDuration > 0) {
                const widthPercent = Math.min((baseAnimDuration / maxTimeVisible) * 100, 100);
                baseAnimTrack.style.width = `${widthPercent}%`;
            } else {
                baseAnimTrack.style.width = '0%';
            }
        }
        
        function updateGlossTrack() {
            if (glossAnimDuration > 0) {
                const glossInsertTime = parseFloat(baseCutStartInput.value) || 0;
                const glossStartTime = parseFloat(glossPlayStartInput.value) || 0;
                const glossEndTime = parseFloat(glossPlayEndInput.value) || glossAnimDuration;
                const glossSegmentDuration = glossEndTime - glossStartTime;
                
                if (glossSegmentDuration <= 0) {
                    glossAnimTrack.style.width = '0%';
                    glossAnimTrack.style.left = '0%';
                    return;
                }
                
                const startPos = ((glossInsertTime + glossStartTime) / maxTimeVisible) * 100;
                const widthPercent = (glossSegmentDuration / maxTimeVisible) * 100;
                
                glossAnimTrack.style.left = `${Math.min(startPos, 100)}%`;
                glossAnimTrack.style.width = `${Math.min(widthPercent, 100 - startPos)}%`;
                
                // Update insertion marker
                updateGlossInsertionMarker(glossInsertTime);
            } else {
                glossAnimTrack.style.width = '0%';
                glossAnimTrack.style.left = '0%';
            }
        }
        
        function updateGlossInsertionMarker(time) {
            const positionPercent = (time / maxTimeVisible) * 100;
            glossInsertionMarker.style.left = `${Math.min(positionPercent, 100)}%`;
        }
        
        function resetTimeline() {
            currentTime = 0;
            updatePlayheadPositions();
            
            // Stop any playing animations
            if (isPlaying) {
                togglePlayback(); // This will stop playback
            }
            
            // Reset animations
            if (window.currentBaseAnim) {
                window.currentBaseAnim.reset();
            }
            if (window.currentGlossAnim) {
                window.currentGlossAnim.reset();
            }
        }
        
        // Connect to Apply Blend Button to update timeline after applying
        document.getElementById('applyBlendButton').addEventListener('click', function() {
            // After a slight delay to let animations get loaded and calculated
            setTimeout(function() {
                // Update timeline visualizations
                if (window.currentBaseAnim) {
                    const fps = window.currentBaseAnim.targetedAnimations[0]?.animation.framePerSecond || 30;
                    baseAnimDuration = window.currentBaseAnim.to / fps;
                }
                
                if (window.currentGlossAnim) {
                    const fps = window.currentGlossAnim.targetedAnimations[0]?. animation.framePerSecond || 30;
                    glossAnimDuration = window.currentGlossAnim.to / fps;
                }
                
                updateBaseTrack();
                updateGlossTrack();
                resetTimeline();
                
                // Start playback if not already playing
                if (!isPlaying) {
                    togglePlayback();
                }
            }, 200);
        });
        
        // Initial update
        resetTimeline();

        // Add hover scrubbing for immediate animation preview
        const timelineTracksContainer = document.querySelector('.timeline-tracks');
    
        if (timelineTracksContainer) {
            timelineTracksContainer.addEventListener('mousemove', function(e) {
                // Only apply hover scrubbing when not dragging and not playing
                if (!isTimelineDragging && !isPlaying) {
                    const rect = this.getBoundingClientRect();
                    const relativeX = Math.max(0, Math.min(e.clientX - rect.left, rect.width));
                    const timePosition = (relativeX / rect.width) * maxTimeVisible;
                    currentTime = Math.max(0, timePosition);
                    
                    // Update playhead position
                    updatePlayheadPositions();
                    
                    // Update animation position for preview
                    if (window.currentBaseAnim) {
                        const fps = window.currentBaseAnim.targetedAnimations[0]?.animation.framePerSecond || 30;
                        const frame = currentTime * fps;
                        
                        // Use goToFrame if available, otherwise normalize to position
                        if (typeof window.currentBaseAnim.goToFrame === 'function') {
                            window.currentBaseAnim.goToFrame(frame);
                        } else {
                            try {
                                // Ensure animation is started but paused
                                if (!window.currentBaseAnim.isStarted) {
                                    window.currentBaseAnim.start(false, 1.0);
                                    window.currentBaseAnim.pause();
                                }
                                
                                // Position the animation at the specific frame
                                if (typeof window.currentBaseAnim._normalize === 'function') {
                                    window.currentBaseAnim._normalize(frame);
                                }
                            } catch (err) {
                                console.warn("Could not position animation:", err);
                            }
                        }
                    }
                }
            });
            
            // Ensure animations start paused for scrubbing
            timelineTracksContainer.addEventListener('mouseenter', function() {
                if (!isPlaying && window.currentBaseAnim && !window.currentBaseAnim.isStarted) {
                    window.currentBaseAnim.start(false, 1.0);
                    window.currentBaseAnim.pause();
                }
            });
        }

    }); // Closing of DOMContentLoaded listener

    // Add drag and resize functionality for timeline clips
    const baseClip = document.getElementById('baseAnimTrack');
    const glossClip = document.getElementById('glossAnimTrack');
    let isDragging = false;
    let isResizing = false;
    let resizeDirection = ''; // 'start' or 'end'
    let activeClip = null;
    let startX = 0;
    let clipStartPos = 0;
    let clipWidth = 0;
    
    // Initialize the blend balance input connection
    const blendBalanceSlider = document.getElementById('blendBalance');
    const blendBalanceValue = document.getElementById('blendBalanceValue');
    
    if (blendBalanceSlider && blendBalanceValue) {
        blendBalanceSlider.addEventListener('input', function() {
            blendBalanceValue.value = this.value;
            // Store the blend balance for use in animation blending
            window.animationBlendBalance = parseFloat(this.value);
            console.log(`Blend balance set to ${window.animationBlendBalance}`);
        });
        
        blendBalanceValue.addEventListener('input', function() {
            const value = parseFloat(this.value);
            if (!isNaN(value) && value >= 0 && value <= 1) {
                blendBalanceSlider.value = value;
                window.animationBlendBalance = value;
                console.log(`Blend balance set to ${window.animationBlendBalance}`);
            }
        });
        
        // Set initial value
        window.animationBlendBalance = 0.5;
    }
    
    // Mouse event handlers for clip dragging and resizing
    function setupClipInteraction(clip, trackType) {
        if (!clip) return;
        
        clip.addEventListener('mousedown', function(e) {
            e.stopPropagation(); // Prevent track click event
            
            const clipRect = clip.getBoundingClientRect();
            const leftEdge = e.clientX - clipRect.left < 8;
            const rightEdge = clipRect.right - e.clientX < 8;
            
            if (leftEdge) {
                // Resize from start
                isResizing = true;
                resizeDirection = 'start';
                activeClip = clip;
            } else if (rightEdge) {
                // Resize from end
                isResizing = true;
                resizeDirection = 'end';
                activeClip = clip;
            } else {
                // Drag whole clip
                isDragging = true;
                activeClip = clip;
            }
            
            startX = e.clientX;
            clipStartPos = parseFloat(clip.style.left) || 0;
            clipWidth = parseFloat(clip.style.width) || 0;
            
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
        });
    }
    
    setupClipInteraction(baseClip, 'base');
    setupClipInteraction(glossClip, 'gloss');
    
    function handleMouseMove(e) {
        if (!activeClip || (!isDragging && !isResizing)) return;
        
        const tracksContainer = document.querySelector('.timeline-tracks');
        const trackWidth = tracksContainer.clientWidth;
        const deltaX = e.clientX - startX;
        const deltaPercent = (deltaX / trackWidth) * 100;
        
        if (isDragging) {
            // Dragging the clip
            let newLeft = clipStartPos + deltaPercent;
            newLeft = Math.max(0, Math.min(newLeft, 100 - clipWidth)); // Constrain to track
            activeClip.style.left = `${newLeft}%`;
            
            // Update time values based on drag position
            if (activeClip === baseClip) {
                // Can't drag base clip, it starts at 0
                activeClip.style.left = '0%'; 
            } else if (activeClip === glossClip) {
                // Gloss clip position affects insertion time
                const newInsertTime = (newLeft / 100) * maxTimeVisible - parseFloat(glossPlayStartInput.value);
                if (newInsertTime >= 0) {
                    baseCutStartInput.value = newInsertTime.toFixed(1);
                    updateGlossInsertionMarker(newInsertTime);
                }
            }
        } else if (isResizing) {
            if (activeClip === baseClip) {
                // Base clip can only be resized from the end
                if (resizeDirection === 'end') {
                    let newWidth = clipWidth + deltaPercent;
                    newWidth = Math.max(1, Math.min(newWidth, 100)); // Min 1%, max 100%
                    activeClip.style.width = `${newWidth}%`;
                    
                    // Update base animation duration
                    const newDuration = (newWidth / 100) * maxTimeVisible;
                    baseAnimDuration = newDuration;
                }
            } else if (activeClip === glossClip) {
                const glossInsertTime = parseFloat(baseCutStartInput.value) || 0;
                
                if (resizeDirection === 'start') {
                    // Resize from start - affects glossPlayStartTime
                    let newLeft = clipStartPos + deltaPercent;
                    let newWidth = clipWidth - deltaPercent;
                    
                    if (newWidth >= 1 && newLeft >= 0) {
                        activeClip.style.left = `${Math.max(0, newLeft)}%`;
                        activeClip.style.width = `${Math.max(1, newWidth)}%`;
                        
                        // Update gloss start time
                        const glossInsertPercent = (glossInsertTime / maxTimeVisible) * 100;
                        const newStartTime = ((newLeft - glossInsertPercent) / 100) * maxTimeVisible;
                        if (newStartTime >= 0) {
                            glossPlayStartInput.value = newStartTime.toFixed(1);
                        }
                    }
                } else if (resizeDirection === 'end') {
                    // Resize from end - affects glossPlayEndTime
                    let newWidth = clipWidth + deltaPercent;
                    newWidth = Math.max(1, Math.min(newWidth, 100 - clipStartPos)); // Min 1%, max to track end
                    activeClip.style.width = `${newWidth}%`;
                    
                    // Update gloss end time
                    const newGlossSegmentDuration = (newWidth / 100) * maxTimeVisible;
                    const newEndTime = parseFloat(glossPlayStartInput.value) + newGlossSegmentDuration;
                    if (newEndTime > parseFloat(glossPlayStartInput.value)) {
                        glossPlayEndInput.value = newEndTime.toFixed(1);
                    }
                }
            }
        }
    }
    
    function handleMouseUp() {
        isDragging = false;
        isResizing = false;
        activeClip = null;
        
        document.removeEventListener('mousemove', handleMouseMove);
        document.removeEventListener('mouseup', handleMouseUp);
        
        // Update tracks to ensure everything is in sync with input values
        updateBaseTrack();
        updateGlossTrack();
    }

    // Make these functions globally accessible for the drag handlers
    window.updateBaseTrack = function() {
        if (window.baseAnimDuration > 0) {
            const widthPercent = Math.min((window.baseAnimDuration / window.maxTimeVisible) * 100, 100);
            baseAnimTrack.style.width = `${widthPercent}%`;
        } else {
            baseAnimTrack.style.width = '0%';
        }
    }
    
    window.updateGlossTrack = function() {
        if (window.glossAnimDuration > 0) {
            const glossInsertTime = parseFloat(window.baseCutStartInput.value) || 0;
            const glossStartTime = parseFloat(window.glossPlayStartInput.value) || 0;
            const glossEndTime = parseFloat(window.glossPlayEndInput.value) || window.glossAnimDuration;
            const glossSegmentDuration = glossEndTime - glossStartTime;
            
            if (glossSegmentDuration <= 0) {
                glossAnimTrack.style.width = '0%';
                glossAnimTrack.style.left = '0%';
                return;
            }
            
            const startPos = ((glossInsertTime + glossStartTime) / window.maxTimeVisible) * 100;
            const widthPercent = (glossSegmentDuration / window.maxTimeVisible) * 100;
            
            glossAnimTrack.style.left = `${Math.min(startPos, 100)}%`;
            glossAnimTrack.style.width = `${Math.min(widthPercent, 100 - startPos)}%`;
            
            // Update insertion marker
            window.updateGlossInsertionMarker(glossInsertTime);
        } else {
            glossAnimTrack.style.width = '0%';
            glossAnimTrack.style.left = '0%';
        }
    }
    
    window.updateGlossInsertionMarker = function(time) {
        const positionPercent = (time / window.maxTimeVisible) * 100;
        glossInsertionMarker.style.left = `${Math.min(positionPercent, 100)}%`;
    }

    // Add hover scrubbing for immediate animation preview
    const timelineTracksContainer = document.querySelector('.timeline-tracks');
    
    if (timelineTracksContainer) {
        timelineTracksContainer.addEventListener('mousemove', function(e) {
            // Only apply hover scrubbing when not dragging and not playing
            if (!isTimelineDragging && !isPlaying) {
                const rect = this.getBoundingClientRect();
                const relativeX = Math.max(0, Math.min(e.clientX - rect.left, rect.width));
                const timePosition = (relativeX / rect.width) * maxTimeVisible;
                currentTime = Math.max(0, timePosition);
                
                // Update playhead position
                updatePlayheadPositions();
                
                // Update animation position for preview
                if (window.currentBaseAnim) {
                    const fps = window.currentBaseAnim.targetedAnimations[0]?.animation.framePerSecond || 30;
                    const frame = currentTime * fps;
                    
                    // Use goToFrame if available, otherwise normalize to position
                    if (typeof window.currentBaseAnim.goToFrame === 'function') {
                        window.currentBaseAnim.goToFrame(frame);
                    } else {
                        try {
                            // Ensure animation is started but paused
                            if (!window.currentBaseAnim.isStarted) {
                                window.currentBaseAnim.start(false, 1.0);
                                window.currentBaseAnim.pause();
                            }
                            
                            // Position the animation at the specific frame
                            if (typeof window.currentBaseAnim._normalize === 'function') {
                                window.currentBaseAnim._normalize(frame);
                            }
                        } catch (err) {
                            console.warn("Could not position animation:", err);
                        }
                    }
                }
            }
        });
        
        // Ensure animations start paused for scrubbing
        timelineTracksContainer.addEventListener('mouseenter', function() {
            if (!isPlaying && window.currentBaseAnim && !window.currentBaseAnim.isStarted) {
                window.currentBaseAnim.start(false, 1.0);
                window.currentBaseAnim.pause();
            }
        });
    }
</script>
